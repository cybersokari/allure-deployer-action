import pLimit from "p-limit";
import { Order } from "../interfaces/storage-provider.interface.js";
import path from "node:path";
export class GoogleStorageService {
    constructor(storageBucket, prefix) {
        this.bucket = storageBucket;
        this.prefix = prefix ? path.normalize(prefix + '/') : undefined;
    }
    async upload(filePath, destination) {
        await this.bucket.upload(filePath, { validation: true, destination: path.join(this.prefix ?? '', destination) });
    }
    async getFiles({ matchGlob, order = Order.byNewestToOldest, maxResults, endOffset }) {
        let [files] = await this.bucket.getFiles({ endOffset, maxResults, matchGlob, prefix: this.prefix });
        return this.sortFiles(files, order);
    }
    async download({ destination, concurrency = 10, files }) {
        const limit = pLimit(concurrency);
        const downloadPromises = [];
        for (const file of files) {
            downloadPromises.push(limit(async () => {
                // Remove the preceding storageHomeDir path from the downloaded file
                const finalDestination = path.join(destination, path.basename(file.name));
                await file.download({ destination: finalDestination, validation: true });
                return finalDestination;
            }));
        }
        return await Promise.all(downloadPromises);
    }
    sortFiles(files, order) {
        if (!files || files.length < 2) {
            return files;
        }
        files = files.filter(file => file.metadata.timeCreated);
        return files.sort((a, b) => {
            const aTime = new Date(a.metadata.timeCreated).getTime();
            const bTime = new Date(b.metadata.timeCreated).getTime();
            return order === Order.byOldestToNewest ? aTime - bTime : bTime - aTime;
        });
    }
    async deleteFile(file) {
        await this.bucket.file(file).delete();
    }
    async deleteFiles(matchGlob = '**.zip') {
        await this.bucket.deleteFiles({ prefix: this.prefix, matchGlob });
    }
}
